# AGENTS.md

Dart/Flutter monorepo for the Convex client SDK. Three packages:
- `convex_dart/` — Core Flutter FFI plugin (Rust via flutter_rust_bridge)
- `convex_dart_cli/` — CLI code generator (pure Dart)
- `example/` — Example app with integration tests

## Build & Dependencies

Dart workspace (SDK `^3.8.0`). From root:
```bash
dart pub get                  # resolves all workspace packages
```
Individual packages require different SDKs:
- `convex_dart`: Dart `^3.8.1`, Flutter `>=3.3.0`
- `convex_dart_cli`: Dart `^3.9.0` (no Flutter)

## Lint / Analyze

All packages use `package:lints/recommended.yaml` (`example/` uses `flutter_lints`).
```bash
dart analyze convex_dart/
dart analyze convex_dart_cli/
dart analyze example/
```
Fix all analyzer warnings before committing. No custom lint rules beyond the recommended set.

## Tests

All tests are **Flutter integration tests** in `example/integration_test/`. They require a running Convex backend (the example connects to a live deployment).

```bash
# Run all integration tests (from example/):
flutter test integration_test/

# Run a single test file:
flutter test integration_test/tasks_crud_test.dart

# Run a single test by name:
flutter test integration_test/tasks_crud_test.dart --name "Create Task - Basic"
```

Test files:
- `tasks_crud_test.dart` — CRUD operations and real-time stream subscriptions
- `serialization_test.dart` — Round-trip serialization for all generated types
- `primitive_test.dart` — Primitive return types (string, number, bool, etc.)
- `http_test.dart` — HTTP endpoint tests (GET, POST, PUT, DELETE, PATCH)
- `auth_test.dart` — Authentication token test

There are no unit tests in `convex_dart/` or `convex_dart_cli/`.

## Code Generation

Four code generation systems are in use. **Never edit generated files.**

```bash
# flutter_rust_bridge — generates Dart FFI bindings from Rust
# Config: convex_dart/flutter_rust_bridge.yaml
# Output: convex_dart/lib/src/rust/

# freezed — immutable sealed classes for Rust bridge types
# Output: *.freezed.dart files in convex_dart/lib/src/rust/
dart run build_runner build    # from convex_dart/

# dart_mappable — JSON serialization in CLI package
# Output: types.mapper.dart
dart run build_runner build    # from convex_dart_cli/

# convex_dart_cli — generates typed Dart client code from Convex function specs
# Output: lib/src/convex/ in target project (e.g. example/)
dart run convex_dart_cli generate
```

Generated files are identified by header comments like `// This file is automatically generated` or `// @generated` and use `// ignore_for_file:` lint suppression blocks.

## Code Style

### File Naming
- Hand-written files: `snake_case.dart` (e.g., `internal_convex_client.dart`, `encode.dart`)
- Generated function files use `camelCase.dart` matching the function name

### Naming Conventions
- Classes: `PascalCase` — `InternalConvexClient`, `ConvexError`, `Uint8ListWithEquality`
- Abstract interfaces: `abstract interface class TableId`, `abstract interface class Literal<T>`
- Methods/functions: `camelCase` — `encodeValue()`, `decodeValue()`, `hashmapToBtreemap()`
- Variables/fields: `camelCase` — `deploymentUrl`, `clientId`
- Private members: underscore prefix — `_instance`, `_client`, `_handleConvexCallback()`
- Type parameters: single capitals — `<T>`, `<R>`; union generics use `<X1, X2, X3, ...>`

### Imports
Order: `dart:` first, then `package:`, then relative. Blank line between groups.
```dart
import 'dart:async';

import 'package:convex_dart/src/rust/dart.dart';
import 'package:locked_async/locked_async.dart';
```
Use `show` clauses to limit exported symbols. Use `as` prefix for disambiguation (`import 'package:path/path.dart' as path`).

### Type Annotations
- Always explicit return types on functions and methods
- Always explicit types on fields and parameters
- Use `required` for named parameters in public APIs
- Use `final` for local variables (prefer type inference with `final`, avoid `var`)
- Use `late final` for deferred initialization

### Parameters
Public APIs use **named required parameters** almost exclusively:
```dart
Future<Value> query({
  required String name,
  required BTreeMapStringValue args,
}) async { ... }
```

### Error Handling
Two-level exception hierarchy with private constructors:
```dart
ConvexClientError implements Exception     // network, internal, server errors
  ConvexError extends ConvexClientError    // application errors with data payload
```
Rust FFI errors are caught and converted via `_handleConvexCallback<T>()`. In streams, errors are forwarded via `controller.addError()`. In the CLI, use try/catch with detailed error messages including troubleshooting hints. Use `UnimplementedError` for unsupported features, `StateError` for invalid states.

### Documentation
- Use `///` doc comments on all public APIs in `convex_dart`
- Include parameter descriptions, return types, `Throws:` sections, and code examples
- Use `//` for implementation notes and inline remarks
- CLI internal code has minimal documentation

### Null Safety & Optional
Full sound null safety (Dart 3.8+). The project distinguishes "undefined" from "null" using a custom `Optional<T>` sealed class (`Defined<T>` / `Undefined<T>`) — this models JavaScript's undefined vs null for Convex field semantics. Use `Optional.undefined()` for absent fields, `Optional.defined(value)` for present values (including null if `T` is nullable).

### Async Patterns
- `async`/`await` consistently; all client operations return `Future<T>`
- `LockedAsync` from `locked_async` for serializing concurrent async operations
- `state.guard()` inside `lock.run()` for cancellation safety
- `StreamController` with manual `onListen`/`onCancel` lifecycle management
- Tests use `Completer<void>` with `.timeout()` for stream assertions

### Collections
Use `IList`, `IMap`, `ISet` from `fast_immutable_collections` as standard return types (not mutable `List`/`Map`/`Set`). Convert with `.lock`, `.toIList()`, `.unlockLazy`.

### Modern Dart 3 Features
- **Sealed classes**: `Optional<T>`, `JsType`, `BaseNode`, and all Rust bridge types
- **Extension types**: `Union2` through `Union9` for type-safe unions
- **Pattern matching**: `switch` expressions in `encodeValue()`/`decodeValue()` and `case Type name:` patterns
- **Records**: generated `api` object and function argument typedefs use Dart 3 records
- **`const` constructors**: used wherever possible on value types

### Equality
Value types implement `operator ==`, `hashCode`, and `toString()`. Pattern:
```dart
@override
bool operator ==(Object other) {
  if (other is SomeType) return field == other.field;
  return false;
}
@override
int get hashCode => field.hashCode;
```

### Exports
The public barrel (`convex_dart.dart`) uses selective `show` exports to hide internals. A separate internal barrel (`convex_dart_for_generated_code.dart`) exports symbols needed by generated code only — marked with `library;` directive and a comment that it is not for public use.

## Architecture Notes

- Rust FFI: The core Convex protocol (websockets, sync, serialization) is implemented in Rust at `convex_dart/rust/`. Dart talks to it via `flutter_rust_bridge`.
- Singleton: `InternalConvexClient` uses a static `_instance` with private named constructor `._internal()`. The public API does NOT export the client class directly — it is only accessible via generated code.
- The CLI reads Convex `function-spec` JSON output and generates a typed Dart client with serialize/deserialize functions, using `@pragma("vm:prefer-inline")` for performance.
