import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'package:path/path.dart' as path;
import 'package:build/build.dart';
import 'package:convex_dart_builder/src/types.dart';
// ignore: implementation_imports
import 'package:build_runner_core/src/generate/build_step_impl.dart';

/// Returns a [Builder] for router generation
Builder convexDartBuilder(BuilderOptions options) {
  if (options.config['input_file'] == null) {
    throw Exception(
      'convex_dart_builder requires that the input_file option is set in the build.yaml file',
    );
  }
  return ConvexDartBuilder(options);
}

class ConvexDartBuilder extends Builder {
  final BuilderOptions options;

  ConvexDartBuilder(this.options);

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    if (buildStep.inputId.path != options.config['input_file']) {
      return;
    }
    // Read the schema.json file
    final contents = await buildStep.readAsString(buildStep.inputId);

    // Get the absolute path to the schema.json file
    final buildStepImpl = buildStep as BuildStepImpl;
    final schemaPath = buildStepImpl.assetPathProvider.pathFor(
      buildStep.inputId,
    );
    // Get a list of all the .dart files in the lib directory
    final libPath = path.dirname(schemaPath);
    final libDir = Directory(libPath);
    // Wipe any existing dart files
    await wipeDartFiles(libDir);

    final FunctionsSpec functionsSpec;
    try {
      functionsSpec = FunctionsSpecMapper.fromJson(contents);
    } catch (e) {
      print(
        "Failed to parse $schemaPath file as a FunctionsSpec. Check the file and ensure it is valid.\nContents: $contents",
      );
      rethrow;
    }

    final clientBuildContext = ClientBuildContext();
    await functionsSpec.build(clientBuildContext);
    for (final entry in clientBuildContext.outputs.entries) {
      final filePath = path.join(libPath, entry.key);
      final file = File(filePath);

      await file.create(recursive: true);
      await file.writeAsString(entry.value);
    }

    // Generate a _ignore.dart file to prevent build_runner from ignoring rebuilds
    final assetId = buildStep.inputId.changeExtension("_ignore.dart");
    await buildStep.writeAsString(
      assetId,
      "// Generated by convex_dart_builder ${Random().nextInt(1000000)}",
    );
  }

  @override
  Map<String, List<String>> get buildExtensions => {
    ".json": ["**", "_ignore.dart"],
  };
}

// Future<void> removeEmptyDirs(Directory dir) async {
//   await for (final dir in dir.list(recursive: true)) {
//     if (dir is Directory) {
//       final containsFiles = await checkContainsFiles(dir);
//       if (!containsFiles) {
//         await dir.delete(recursive: true);
//       }
//     }
//   }
// }

// Future<bool> checkContainsFiles(Directory dir) async {
//   await for (final file in dir.list()) {
//     if (file is File) {
//       return true;
//     } else if (file is Directory) {
//       if (await checkContainsFiles(file)) {
//         return true;
//       }
//     }
//   }
//   return false;
// }

Future<void> wipeDartFiles(Directory dir) async {
  await for (final file in dir.list(recursive: true)) {
    if (file is File && file.path.endsWith(".dart")) {
      await file.delete();
    }
  }
}
